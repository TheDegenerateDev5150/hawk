// Code generated by hawk. DO NOT EDIT.
// Rerunning hawk will overwrite this file.
// Version: {{.Version}}
// Version Date: {{.VersionDate}}

package svc

import (
	"context"
	"encoding/json"
	"github.com/go-kit/kit/endpoint"
	transport "github.com/go-kit/kit/transport/http"
	"github.com/google/uuid"
	"github.com/gorilla/websocket"
	"github.com/sirupsen/logrus"
	"net/http"
	"sync"
	"time"
	// This service
	pb "{{.PBImportPath -}}"
)

const (
	pongWait	   = 20 * time.Second
	pingPeriod	 = (pongWait * 9) / 10
	{{- if gt .HTTPHelper.Service.WSMaxSize 0 }}
		maxMessageSize = {{.HTTPHelper.Service.WSMaxSize}}
	{{- end }}
)

type WebSocketConfig struct {
	Guard         func(ctx context.Context, r *http.Request) (context.Context, error)
	OriginChecker func(r *http.Request) bool
}

type Message struct {
	Method    string          `json:"method"`
	Data	  json.RawMessage `json:"data,omitempty"`
	Command   string          `json:"command,omitempty"`
	RequestID string          `json:"request_id,omitempty"`
	Status    int             `json:"status,omitempty"`
}

type Pool struct {
	log	   *logrus.Entry
	upgrade   websocket.Upgrader
	guard     func(ctx context.Context, r *http.Request) (context.Context, error)
	endpoints map[string]endpoint.Endpoint
	decoders  map[string]func(json.RawMessage) (interface{}, error)
	clients   map[*Client]bool
	sync.RWMutex
}

type Client struct {
	id         string
	log        *logrus.Entry
	connection *websocket.Conn
	pool       *Pool
	ctx        context.Context

	out chan Message
}

func NewPool(log *logrus.Entry, endpoints Endpoints, wsCfg WebSocketConfig) *Pool {
	p := &Pool{
		log:	 log,
		clients: make(map[*Client]bool),
		upgrade: websocket.Upgrader{
			CheckOrigin:     wsCfg.OriginChecker,
			ReadBufferSize:  1024,
			WriteBufferSize: 1024,
		},
		guard:     wsCfg.Guard,
		endpoints: make(map[string]endpoint.Endpoint),
		decoders:  make(map[string]func(json.RawMessage) (interface{}, error)),
	}

	{{range $i := .Service.Methods}}
		{{ if and (not $i.RequestStream) (not $i.ResponseStream) }}
			p.endpoints["{{$i.Name}}"] = endpoints.{{$i.Name}}Endpoint
			p.decoders["{{$i.Name}}"] = p.decoder{{$i.Name}}
		{{ end }}
	{{- end}}

	return p
}

func (p *Pool) AddClient(ctx context.Context, connection *websocket.Conn) *Client {
	id := uuid.NewString()
	c := &Client{
		id:		 id,
		connection: connection,
		pool:	   p,
		log: p.log.WithFields(logrus.Fields{
			"transport": "WEBSOCKET",
			"client":	id,
		}),
		ctx: context.WithValue(ctx, "transport", "WEBSOCKET"),
		out: make(chan Message),
	}
	c.log.Info("[WS] client connected")
	p.clients[c] = true

	return c
}

func (p *Pool) removeClient(client *Client) {
	p.Lock()
	defer p.Unlock()
	if _, ok := p.clients[client]; ok {
		close(client.out)
		_ = client.connection.Close()
		delete(p.clients, client)
	}
}

func (c *Client) readMessages() {
	defer func() {
		c.pool.removeClient(c)
	}()

	{{ if gt .HTTPHelper.Service.WSMaxSize 0 }}
		c.connection.SetReadLimit(maxMessageSize)
	{{ end }}
	if err := c.connection.SetReadDeadline(time.Now().Add(pongWait)); err != nil {
		return
	}

	c.connection.SetPongHandler(func(string) error {
		return c.connection.SetReadDeadline(time.Now().Add(pongWait))
	})

	for {
		_, payload, err := c.connection.ReadMessage()

		if err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				c.log.WithError(err).Info("[WS] unexpected close")
			} else {
				c.log.WithError(err).Info("[WS] close")
			}
			break
		}

		var msg Message
		if err = json.Unmarshal(payload, &msg); err != nil {
			c.log.WithError(err).Info("[WS] invalid message received")
			continue
		}

		log := c.log.WithField("method", msg.Method)
		if e, ok := c.pool.endpoints[msg.Method]; ok {
			data, err := c.pool.decoders[msg.Method](msg.Data)
			msg = Message{
				Method:    msg.Method,
				RequestID: msg.RequestID,
				Status:    http.StatusOK,
			}
			if err != nil {
				log.WithError(err).Info("[WS] error decoding message")
				msg.encodeError(err)
				msg.Status = http.StatusBadRequest
				c.out <- msg
				continue
			}
			response, err := e(c.ctx, data)
			if err != nil {
				log.WithError(err).Info("[WS] error executing endpoint")
				msg.encodeError(err)
			} else {
				msg.Data, err = json.Marshal(response)
				if err != nil {
					log.WithError(err).Error("[WS] error marshalling response")
					msg.encodeError(err)
				}
			}
			c.out <- msg
		}
	}
}

func (c *Client) writeMessages() {
	ticker := time.NewTicker(pingPeriod)
	defer func() {
		ticker.Stop()
		c.pool.removeClient(c)
	}()

	for {
		select {
		case message, ok := <-c.out:
			if !ok {
				if err := c.connection.WriteMessage(websocket.CloseMessage, nil); err != nil {
					c.log.WithError(err).Info("[WS] error closing connection")
				} else {
					c.log.Info("[WS] connection closed")
				}
				return
			}
			data, err := json.Marshal(message)
			if err != nil {
				c.log.WithError(err).Error("[WS] error marshalling message")
				continue
			}

			if err = c.connection.WriteMessage(websocket.TextMessage, data); err != nil {
				c.log.WithError(err).Info("[WS] error writing message")
			}
		case <-ticker.C:
			if err := c.connection.WriteMessage(websocket.PingMessage, []byte{}); err != nil {
				c.log.WithError(err).Info("[WS] error writing ping")
				return
			}
		}
	}
}

func (p *Pool) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    ctx := context.Background()
	if p.guard != nil {
		var err error
		ctx, err = p.guard(ctx, r)
		if err != nil {
			errorEncoder(nil, err, w)
			return
		}
	}

	conn, err := p.upgrade.Upgrade(w, r, nil)
	if err != nil {
		return
	}

	client := p.AddClient(ctx, conn)
	go client.readMessages()
	go client.writeMessages()
}

func (m *Message) encodeError(err error) {
	data, _ := json.Marshal(errorWrapper{Error: err.Error()})
	if marshaler, ok := err.(json.Marshaler); ok {
		if jsonBody, marshalErr := marshaler.MarshalJSON(); marshalErr == nil {
			data = jsonBody
		}
	}
	code := http.StatusInternalServerError
	if sc, ok := err.(transport.StatusCoder); ok {
		code = sc.StatusCode()
	}
	m.Data = data
	m.Status = code
}

{{range $i := .Service.Methods}}
	{{ if and (not $i.RequestStream) (not $i.ResponseStream) }}
		func (p *Pool) decoder{{$i.Name}}(data json.RawMessage) (interface{}, error) {
			r := &pb.{{GoName $i.Request}}{}
			return r, json.Unmarshal(data, &r)
		}
	{{ end }}
{{end}}
